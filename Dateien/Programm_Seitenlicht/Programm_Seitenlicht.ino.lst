
C:\Users\student\AppData\Local\Temp\arduino_build_347443/Programm_Seitenlicht.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	0e c0       	rjmp	.+28     	; 0x1e <__ctors_end>
   2:	1d c0       	rjmp	.+58     	; 0x3e <__bad_interrupt>
   4:	1c c0       	rjmp	.+56     	; 0x3e <__bad_interrupt>
   6:	1b c0       	rjmp	.+54     	; 0x3e <__bad_interrupt>
   8:	1a c0       	rjmp	.+52     	; 0x3e <__bad_interrupt>
   a:	25 c0       	rjmp	.+74     	; 0x56 <__vector_5>
   c:	18 c0       	rjmp	.+48     	; 0x3e <__bad_interrupt>
   e:	17 c0       	rjmp	.+46     	; 0x3e <__bad_interrupt>
  10:	16 c0       	rjmp	.+44     	; 0x3e <__bad_interrupt>
  12:	15 c0       	rjmp	.+42     	; 0x3e <__bad_interrupt>
  14:	14 c0       	rjmp	.+40     	; 0x3e <__bad_interrupt>
  16:	13 c0       	rjmp	.+38     	; 0x3e <__bad_interrupt>
  18:	12 c0       	rjmp	.+36     	; 0x3e <__bad_interrupt>
  1a:	11 c0       	rjmp	.+34     	; 0x3e <__bad_interrupt>
  1c:	10 c0       	rjmp	.+32     	; 0x3e <__bad_interrupt>

0000001e <__ctors_end>:
__trampolines_start():
  1e:	11 24       	eor	r1, r1
  20:	1f be       	out	0x3f, r1	; 63
  22:	cf e5       	ldi	r28, 0x5F	; 95
  24:	d2 e0       	ldi	r29, 0x02	; 2
  26:	de bf       	out	0x3e, r29	; 62
  28:	cd bf       	out	0x3d, r28	; 61

0000002a <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  2a:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  2c:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  2e:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  30:	01 c0       	rjmp	.+2      	; 0x34 <.do_clear_bss_start>

00000032 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  32:	1d 92       	st	X+, r1

00000034 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  34:	ae 36       	cpi	r26, 0x6E	; 110
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  36:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  38:	e1 f7       	brne	.-8      	; 0x32 <.do_clear_bss_loop>
.do_clear_bss_start():
  3a:	57 d0       	rcall	.+174    	; 0xea <main>
  3c:	a9 c0       	rjmp	.+338    	; 0x190 <_exit>

0000003e <__bad_interrupt>:
__vector_1():
  3e:	e0 cf       	rjmp	.-64     	; 0x0 <__vectors>

00000040 <digitalWrite.constprop.1>:
digitalWrite.constprop.1():
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
  40:	81 11       	cpse	r24, r1
  42:	05 c0       	rjmp	.+10     	; 0x4e <digitalWrite.constprop.1+0xe>
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:153
    uint8_t oldSREG = SREG;
  44:	8f b7       	in	r24, 0x3f	; 63
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:154
    cli();
  46:	f8 94       	cli
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:155
    *out &= ~bit;
  48:	c3 98       	cbi	0x18, 3	; 24
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:161
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
    SREG = oldSREG;
  4a:	8f bf       	out	0x3f, r24	; 63
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:163
  }
}
  4c:	08 95       	ret
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:158
    uint8_t oldSREG = SREG;
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
  4e:	8f b7       	in	r24, 0x3f	; 63
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:159
    cli();
  50:	f8 94       	cli
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    *out |= bit;
  52:	c3 9a       	sbi	0x18, 3	; 24
  54:	fa cf       	rjmp	.-12     	; 0x4a <digitalWrite.constprop.1+0xa>

00000056 <__vector_5>:
__vector_5():
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:308
      #error "cannot find Millis() timer overflow vector"
    #endif
  #else
    #error "Millis() timer not defined!"
  #endif
  {
  56:	1f 92       	push	r1
  58:	0f 92       	push	r0
  5a:	0f b6       	in	r0, 0x3f	; 63
  5c:	0f 92       	push	r0
  5e:	11 24       	eor	r1, r1
  60:	2f 93       	push	r18
  62:	3f 93       	push	r19
  64:	8f 93       	push	r24
  66:	9f 93       	push	r25
  68:	af 93       	push	r26
  6a:	bf 93       	push	r27
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:311
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = millis_timer_millis;
  6c:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <millis_timer_millis>
  70:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <millis_timer_millis+0x1>
  74:	a0 91 67 00 	lds	r26, 0x0067	; 0x800067 <millis_timer_millis+0x2>
  78:	b0 91 68 00 	lds	r27, 0x0068	; 0x800068 <millis_timer_millis+0x3>
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:312
    unsigned char f = millis_timer_fract;
  7c:	30 91 64 00 	lds	r19, 0x0064	; 0x800064 <millis_timer_fract>
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:319
    static unsigned char correct_exact = 0;     // rollover intended
    if (++correct_exact < CORRECT_EXACT_MANY) {
      ++f;
    }
#endif
    f += FRACT_INC;
  80:	26 e0       	ldi	r18, 0x06	; 6
  82:	23 0f       	add	r18, r19
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:321

    if (f >= FRACT_MAX)
  84:	2d 37       	cpi	r18, 0x7D	; 125
  86:	68 f1       	brcs	.+90     	; 0xe2 <__vector_5+0x8c>
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:323
    {
      f -= FRACT_MAX;
  88:	29 e8       	ldi	r18, 0x89	; 137
  8a:	23 0f       	add	r18, r19
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:324
      m += MILLIS_INC + 1;
  8c:	03 96       	adiw	r24, 0x03	; 3
  8e:	a1 1d       	adc	r26, r1
  90:	b1 1d       	adc	r27, r1
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:331
    else
    {
      m += MILLIS_INC;
    }

    millis_timer_fract = f;
  92:	20 93 64 00 	sts	0x0064, r18	; 0x800064 <millis_timer_fract>
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:332
    millis_timer_millis = m;
  96:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <millis_timer_millis>
  9a:	90 93 66 00 	sts	0x0066, r25	; 0x800066 <millis_timer_millis+0x1>
  9e:	a0 93 67 00 	sts	0x0067, r26	; 0x800067 <millis_timer_millis+0x2>
  a2:	b0 93 68 00 	sts	0x0068, r27	; 0x800068 <millis_timer_millis+0x3>
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:334
#ifndef CORRECT_EXACT_MICROS
    millis_timer_overflow_count++;
  a6:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
  aa:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
  ae:	a0 91 62 00 	lds	r26, 0x0062	; 0x800062 <__DATA_REGION_ORIGIN__+0x2>
  b2:	b0 91 63 00 	lds	r27, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
  b6:	01 96       	adiw	r24, 0x01	; 1
  b8:	a1 1d       	adc	r26, r1
  ba:	b1 1d       	adc	r27, r1
  bc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
  c0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
  c4:	a0 93 62 00 	sts	0x0062, r26	; 0x800062 <__DATA_REGION_ORIGIN__+0x2>
  c8:	b0 93 63 00 	sts	0x0063, r27	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:336
#endif
  }
  cc:	bf 91       	pop	r27
  ce:	af 91       	pop	r26
  d0:	9f 91       	pop	r25
  d2:	8f 91       	pop	r24
  d4:	3f 91       	pop	r19
  d6:	2f 91       	pop	r18
  d8:	0f 90       	pop	r0
  da:	0f be       	out	0x3f, r0	; 63
  dc:	0f 90       	pop	r0
  de:	1f 90       	pop	r1
  e0:	18 95       	reti
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:328
      f -= FRACT_MAX;
      m += MILLIS_INC + 1;
    }
    else
    {
      m += MILLIS_INC;
  e2:	02 96       	adiw	r24, 0x02	; 2
  e4:	a1 1d       	adc	r26, r1
  e6:	b1 1d       	adc	r27, r1
  e8:	d4 cf       	rjmp	.-88     	; 0x92 <__vector_5+0x3c>

000000ea <main>:
main():
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
  ea:	83 e0       	ldi	r24, 0x03	; 3
  ec:	8a bd       	out	0x2a, r24	; 42
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
  ee:	82 e0       	ldi	r24, 0x02	; 2
  f0:	83 bf       	out	0x33, r24	; 51
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
  f2:	78 94       	sei
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1167

  #ifndef DISABLEMILLIS
    // Enable the overflow interrupt (this is the basic system tic-toc for millis)
    #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
      sbi(TIMSK, TOIE0);
  f4:	89 b7       	in	r24, 0x39	; 57
  f6:	82 60       	ori	r24, 0x02	; 2
  f8:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:958
    #elif defined(__AVR_ATtiny43__)
      TCCR1A = 3; //WGM 10=1, WGM11=1
      TCCR1B = 3; //prescaler of 64
    #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1) // ATtiny x5
      // Use the Tone Timer for fast PWM as phase correct not supported by this timer
      GTCCR = (1<<PWM1B);
  fa:	80 e4       	ldi	r24, 0x40	; 64
  fc:	8c bd       	out	0x2c, r24	; 44
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:959
      OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
  fe:	8f ef       	ldi	r24, 0xFF	; 255
 100:	8d bd       	out	0x2d, r24	; 45
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:960
      TCCR1 = (1<<CTC1) | (1<<PWM1A) | (ToneTimer_Prescale_Index << CS10);
 102:	84 ec       	ldi	r24, 0xC4	; 196
 104:	80 bf       	out	0x30, r24	; 48
main():
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 106:	83 e8       	ldi	r24, 0x83	; 131
 108:	86 b9       	out	0x06, r24	; 6
pinMode():
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:57
                cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 10a:	8f b7       	in	r24, 0x3f	; 63
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:58
                cli();
 10c:	f8 94       	cli
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:59
    *reg |= bit;
 10e:	bb 9a       	sbi	0x17, 3	; 23
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:60
    SREG = oldSREG;
 110:	8f bf       	out	0x3f, r24	; 63
setup():
C:\Users\student\AppData\Local\Temp\arduino_modified_sketch_167865/Programm_Seitenlicht.ino:12
 unsigned long previousMillis = 0; 
 const unsigned long interval = 1000; // 1 Sekunde Intervall 
  
  void setup() { 
   pinMode(el, OUTPUT); 
   digitalWrite(el, LOW);     // AUS beim Start 
 112:	80 e0       	ldi	r24, 0x00	; 0
 114:	95 df       	rcall	.-214    	; 0x40 <digitalWrite.constprop.1>
pinMode():
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:45

  reg = portModeRegister(port);
  out = portOutputRegister(port);

  if (mode == INPUT) {
    uint8_t oldSREG = SREG;
 116:	8f b7       	in	r24, 0x3f	; 63
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:46
                cli();
 118:	f8 94       	cli
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:47
    *reg &= ~bit;
 11a:	bc 98       	cbi	0x17, 4	; 23
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:48
    *out &= ~bit;
 11c:	c4 98       	cbi	0x18, 4	; 24
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:49
    SREG = oldSREG;
 11e:	8f bf       	out	0x3f, r24	; 63
digitalRead():
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:180
  // "read" should *NEVER* change the behavior of the thing you're using it on.
  // That's why it's called "read" not "write". As an added bonus, sets the
  // stage for auto-fast-digitalRead() for compile time known pins.
  // if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  if (*portInputRegister(port) & bit) return HIGH;
 120:	b4 99       	sbic	0x16, 4	; 22
 122:	30 c0       	rjmp	.+96     	; 0x184 <main+0x9a>
millis():
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:341
  }

  unsigned long millis()
  {
    unsigned long m;
    uint8_t oldSREG = SREG;
 124:	2f b7       	in	r18, 0x3f	; 63
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:345

    // disable interrupts while we read millis_timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
    cli();
 126:	f8 94       	cli
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:346
    m = millis_timer_millis;
 128:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <millis_timer_millis>
 12c:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <millis_timer_millis+0x1>
 130:	a0 91 67 00 	lds	r26, 0x0067	; 0x800067 <millis_timer_millis+0x2>
 134:	b0 91 68 00 	lds	r27, 0x0068	; 0x800068 <millis_timer_millis+0x3>
C:\Users\student\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:347
    SREG = oldSREG;
 138:	2f bf       	out	0x3f, r18	; 63
loop():
C:\Users\student\AppData\Local\Temp\arduino_modified_sketch_167865/Programm_Seitenlicht.ino:21
 void loop() { 
   if (digitalRead(sw) == LOW) { 
     // Schalter AUS -> Blinken mit millis() 
     unsigned long currentMillis = millis(); 
  
     if (currentMillis - previousMillis >= interval) { 
 13a:	40 91 69 00 	lds	r20, 0x0069	; 0x800069 <previousMillis>
 13e:	50 91 6a 00 	lds	r21, 0x006A	; 0x80006a <previousMillis+0x1>
 142:	60 91 6b 00 	lds	r22, 0x006B	; 0x80006b <previousMillis+0x2>
 146:	70 91 6c 00 	lds	r23, 0x006C	; 0x80006c <previousMillis+0x3>
 14a:	8c 01       	movw	r16, r24
 14c:	9d 01       	movw	r18, r26
 14e:	04 1b       	sub	r16, r20
 150:	15 0b       	sbc	r17, r21
 152:	26 0b       	sbc	r18, r22
 154:	37 0b       	sbc	r19, r23
 156:	b9 01       	movw	r22, r18
 158:	a8 01       	movw	r20, r16
 15a:	48 3e       	cpi	r20, 0xE8	; 232
 15c:	53 40       	sbci	r21, 0x03	; 3
 15e:	61 05       	cpc	r22, r1
 160:	71 05       	cpc	r23, r1
 162:	f0 f2       	brcs	.-68     	; 0x120 <main+0x36>
C:\Users\student\AppData\Local\Temp\arduino_modified_sketch_167865/Programm_Seitenlicht.ino:22
       previousMillis = currentMillis; 
 164:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <previousMillis>
 168:	90 93 6a 00 	sts	0x006A, r25	; 0x80006a <previousMillis+0x1>
 16c:	a0 93 6b 00 	sts	0x006B, r26	; 0x80006b <previousMillis+0x2>
 170:	b0 93 6c 00 	sts	0x006C, r27	; 0x80006c <previousMillis+0x3>
C:\Users\student\AppData\Local\Temp\arduino_modified_sketch_167865/Programm_Seitenlicht.ino:24
       //Zustand umschalten
       ledState = !ledState;    
 174:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <ledState>
 178:	91 e0       	ldi	r25, 0x01	; 1
 17a:	89 27       	eor	r24, r25
 17c:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <ledState>
C:\Users\student\AppData\Local\Temp\arduino_modified_sketch_167865/Programm_Seitenlicht.ino:25
       digitalWrite(el, ledState);   
 180:	5f df       	rcall	.-322    	; 0x40 <digitalWrite.constprop.1>
 182:	ce cf       	rjmp	.-100    	; 0x120 <main+0x36>
C:\Users\student\AppData\Local\Temp\arduino_modified_sketch_167865/Programm_Seitenlicht.ino:29
     } 
   } else { 
     // Schalter AN -> Dauerlicht 
     digitalWrite(el, HIGH); 
 184:	81 e0       	ldi	r24, 0x01	; 1
 186:	5c df       	rcall	.-328    	; 0x40 <digitalWrite.constprop.1>
C:\Users\student\AppData\Local\Temp\arduino_modified_sketch_167865/Programm_Seitenlicht.ino:30
     ledState = HIGH; // Status setzen 
 188:	81 e0       	ldi	r24, 0x01	; 1
 18a:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <ledState>
 18e:	c8 cf       	rjmp	.-112    	; 0x120 <main+0x36>

00000190 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 190:	f8 94       	cli

00000192 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 192:	ff cf       	rjmp	.-2      	; 0x192 <__stop_program>
